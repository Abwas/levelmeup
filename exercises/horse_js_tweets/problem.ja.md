このエクササイズでは[@horse_js](https://twitter.com/horse_js)から２０００以上の
ツイートを保存したLevelDBのデータを使用します。
ある特定の日付に投稿されたツイートを取得するクエリを投げるのが課題です。

エントリにツイートが１つずつ保存されています。ツイートが投稿された日時がキーになっています。
日時はISO形式で保存されています。
（例えば`Date`オブジェクトの`toISOString()`メソッドによって作られたような形式です。)
エントリの値はツイートの内容を表す文字列です。

引数を３つ取る関数を１つだけエクスポートした**module**を作成してください。
１つ目の引数はLevelUPデータベースインスタンスのディレクトリパス、2つ目の引数は`YYYY-MM-DD`形式の日付の文字列、
3つ目の引数はコールバック関数です。

コールバック関数の最初の引数はエラーまたはnullを持つようにしてください。

2つ目の引数には**ツイートのテキストが要素の配列**を持つようにしてください。

1つ目の引数として与えられる**1日**のツイートを配列は含んでいなければいけません。
他の日付のツイートを返してはいけません。

あなたの解答が正解な範囲（詳細は以下）を対象にしているかチェックされます。

---
## ヒント:

ISO形式の日時フォーマットは常に辞書順で並んでおり、
特別な操作をしなくとも、データストアの中でツイートは日付・時間の順番で現れます。

このエクササイズでは、`createReadStream()`メソッドを使用します。
しかし、エントリは必要な範囲のみに絞らなければなりません。

デフォルトでは全てのデータストアを範囲としますが、startキーとendキー、
またはどちらか１つを使用して範囲を絞ることができます。
このエクササイズでは指定した日付の最初から最後までのツイートを
対象にしたいと思うでしょう。

この範囲指定のクエリが強力なのは、指定したstartキーとendキーがデータストアに
存在していなくても良い、という点にあります。
startキーが存在していない場合、ソートされた順番においてstartキーの次に現れる
キーからデータが始まります。
endキーが存在していない場合、ソートされた順番においてendキーの前に現れるキーで
データが終了します。

範囲を絞るために'start'と'end'またはどちらか1つプロパティを持つオブジェクトを`createReadStream()`の引数に設定してください。

```javascript
db.createReadStream({ start: 'bar', end: 'foo' })...
```

指定する範囲の両キーが存在する必要はなく、見つけたいキーの接頭辞の指定さえあれば良い、
という点を忘れないで下さい。
例えば、`2010`は`2010`から始まる最初のキーへジャンプします。それは`2010-09-04T03：51：30.929Z`にマッチするという結果になるかもしれません。

範囲指定クエリの結果は、`end`キーそのもののエントリが含まれるので、所望のキーだけに
マッチする擬似キーを作成する必要があります。
もし`start`に`2010`、`end`に`2011`を使用する場合、`2010`と`2011`の両方から始まるすべてのエントリを取得します。
LevelUPを使用してこれを実現する(唯一ではないが)慣用的な方法は`'\xff'`をキーの最後に付加することです。
これは最後のASCII文字を意味します。ですから、`2010`の`start`と `2010\xff` の`end`は`2010`から始まるキーにだけマッチします。
